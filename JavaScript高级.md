#  JavaScript高级

### 一. 基础总结深入

##### 数据类型

###### 1. 分类

  - 基本(值)数据类型
      - String
      - Number
      - Boolean
      - Null
      - Undefined
      - Symbol
  - 对象(引用)数据类型
    	 - Object
        	 - Function：特殊的对象(可以执行)
          	 - Array：特殊的对象(数值下标，内部数据是有序的)

###### 2. 判断

 - typeof（返回的是对应类型的一个字符串形式）
   	- 可以判断 number boolean string undefined
      	- 不能判断 null 和 object , array 和 object

 - instanceof (返回的是一个布尔值 用来判断 a 是否是 b 的一个实例对象)
   	- 不能判断基本数据类型
      	- 用来判断对象的具体类型
 - ===
   	- 可以判断null undefined

###### 3. 补充

- undefined 与 null 的区别？
  - undefined代表定义了未赋值
  - null定义了 也赋值了 只是值为null
- 什么时候给变量赋值为 null？
  - 初始赋值 表明将要赋值为对象
  - 结束前 让对象成为垃圾对象(被垃圾回收机制回收)
- 严格区别变量类型与数据类型？
  - 数据的类型
    - 基本类型
    - 对象类型i
  - 变量的类型(变量内存值的类型)
    - 基本类型：保存的就是基本类型的数据
    - 引用类型：保存的是地址值

##### 数据 _ 变量 _ 内存

###### 1. 什么是数据？

	- 存储在内存中代表特定信息的 ’ 东东 ‘ ,本质上是 010101...
	- 数据的特点：可传递,可运算
	- 一切皆数据
 - 内存中所有操作的目标：数据
   	- 算术运算
      	- 逻辑运算
      	- 赋值
              	- 运行函数

###### 2. 什么是变量？

	- 可变化的量,由变量名和变量值组成
	- 每个变量都对应的一块小内存,变量名用来查找对应的内存，变量值就是内存中保存的数据

###### 3. 什么是内存？

	- 内存条通电以后产生的可存储数据的空间(临时的)
	- 内存产生和死亡： 内存条(电路板) ==> 通电 ==> 产生内存空间 ==> 存储数据 ==> 处理数据 ==> 断电 ==> 内存空间和数据都消失
 - 一块小内存的 2 个数据
   	- 基本数据
      	- 地址值数据
- 内存的分类
  - 栈：全局变量和局部变量
  - 堆：对象

###### 4. 内存 数据 变量三者之间的关系

	- 内存用来存储数据的空间
 - 变量是内存的标识

###### 5. var a = xxx, a内存中到底保存的是什么？

	- xxx是基本数据类型 ， 保存的就是这个数据
	- xxx是对象 ， 保存的是对象的地址值
	- xxx是一个变量， 保存的xxx的内存内容(可能是基本数据，也可能是地址值)

###### 6. 关于变量赋值问题？

	-  n 个引用变量指向同一个对象，通过一个变量修改对象内部数据，另一个变量看到的是修改之后的数据
	-  2 个引用变量指向同一个对象, 让其中一个引用变量指向另一个对象，另一引用变量依然指向前一个对象

###### 7. 在js调用函数时传递变量参数时，是值传递还是引用传递？

	- 理解一：都是值(基本/地址值)传递
	- 理解二：可能是值传递，也可能是引用传递(地址值)

###### 8. Js引擎如何管理内存？

```
1. 内存的生命周期
    - 分配小内存空间，得到他的使用权
    - 存储数据，可以反复进行操作
    - 释放小内存空间
2. 释放内存
    - 局部变量： 函数执行完自动释放
    - 对象： 成为垃圾对象 ==> 垃圾回收器回收
    - 全局变量： 窗口关闭
```

##### 对象

###### 1. 什么是对象？

```
- 多个数据的封装体
- 用来保存多个数据的容器
- 一个对象代表现实中的一个事务
```

###### 2. 为什么要用对象？

```
- 统一管理多个数据
```

###### 3. 对象的组成？

```
- 属性： 属性名(字符串)和属性值(任意)组成
- 方法： 一种特别的属性(属性值是函数)
```

###### 4. 如何访问对象内部数据？

```
- .属性名: 编码简单，有时不能用
- ['属性名']： 编码麻烦，能通用
```

###### 5.  什么时候必须使用['属性名']的方式？

```
- 属性名包含特殊字符 - 空格
- 属性名不确定
```

##### 函数

###### 1. 什么是函数？

```
- 实现特定功能的 n 条语句的封装体
- 只有函数是可以执行的，其它类型的数据不执行
```

###### 2. 为什么要用函数？

```
- 提高代码复用性
- 便于阅读交流
```

###### 3. 如何定义函数？

```
- 函数声明
- 表达式
```

###### 4. 如何调用(执行)函数？

```
- test()：直接调用
- obj.test(): 通过对象调用
- new test(): new调用
- test.call/apply(obj): 临时让test成为obj的方法进行调用
```

##### 回调函数

###### 1. 什么函数才是回调函数？

```
- 你定义的
- 你没有调用
- 但最终它执行的(在某个时刻或某个条件)
```

###### 2. 常见的回调函数？

```
- dom事件的回调函数
- 定时器回调函数
- Ajax请求回调函数
- 生命周期回调函数
```

##### IIFE

###### 1. 理解

```
全称： Immediately-Invoked Function Expression
```

###### 2. 作用

```
- 隐藏实现
- 不会污染外部(全局)命名空间
- 用它来编码js模块
```

##### 函数中的this

###### 1. this是什么？

```
- 任何函数本质上都是通过某个对象来调用的，如果没有直接指定就是window
- 所有函数内部都有一个变量 this
- 它的值是调用函数的当前对象
```

###### 2. 如何确定this的值

```
- test(): window
- p.test(): p
- new test(): 新创建的对象
- p.call(obj): obj
```

##### 分号问题

###### 1. 以下两种情况不加分号有问题？

```
- 小括号开头的前一条语句
- 中方括号开头的前一条语句
```



### 二. 函数高级

#### 原型与原型链

##### 原型

###### 1. 函数的 prototype 属性

```
- 每个函数都有一个 prototype 属性，它默认指向一个 Object 空对象(即称为原型对象)
- 原型对象中有一个属性 constructor 它指向函数对象
```

###### 2. 给原型对象添加属性(一般都是方法)

```
作用：函数的所有实例对象自动拥有原型中的属性(方法)
```

##### 显示原型与隐式原型

```
1. 每个函数 function 都有一个 prototype , 即显示原型(属性)
2. 每个实例对象都有一个 __proto__, 可称为隐式原型(属性)
3. 对象的隐式原型的值为其对应构造函数的显示原型的值
4. 内存结构
5. 总结：
    - 函数的 prototype 属性： 在定义函数时自动添加，默认值是一个空Object对象
    - 对象的 __proto__属性： 在创建对象时自动添加，默认值为构造函数的 prototype 属性值
    - 程序员能直接操作显示原型，但不能直接操作隐式原型(ES6之前)
```

##### 原型链

```
* 1. 原型链(图解)
*      访问一个对象的属性时：
*          先在自身属性中查找，找到返回
*          如果没有，再沿着__proto__这条链向上查找，找到返回
*          如果最终没找到，返回 undefined
*    别名： 隐式原型链
*    作用：查找对象的属性(方法)
* 2. 构造函数 / 原型 / 实体对象的关系(图解)
* 3. 构造函数 / 原型 / 实体对象的关系2(图解)

* 1. 函数的显示原型指向的对象：默认是空的Object对象(但Object不满足)
* 2. 所有的函数都是 Function 的实例(包括 Function 本身)
* 3. Object 的原型对象是原型链的尽头
```

##### 原型链_属性问题

```
 * 1. 读取对象的属性值时： 会自动到原型链中查找
 * 2. 设置对象的属性值时： 不会查找原型链，如果当前对象中没有此属性，直接添加次属性并设置其值
 * 3. 方法一般定义在原型中，属性一般通过构造函数定义在对象本身
```

##### 探索instanceof

```
 * 1. instanceof是如何判断的？
 *      表达式： A instanceof B
 *      如果B函数的显示原型对象在A对象的原型链上，返回true，否则返回false
 * 2. Function是通过new自己产生的实例
```

#### 执行上下文与执行上下文栈

##### 变量提升与函数提升

```
* 1. 变量声明提升
 *      - 通过var定义(声明)的变量，在定义语句之前就可以访问到
 *      - 值 undefined
 * 2. 函数声明提升
 *      - 通过function声明的函数，在之前就可以直接调用
 *      - 值 函数定义(对象)
 * 3. 问题：变量提升和函数提升是如何产生的？
```

##### 执行上下文

```
 * 1. 代码分类(位置)
 *      - 全局代码
 *      - 函数(局部)代码
 * 2. 全局执行上下文
 *      - 在执行全局代码前将 window 确定为全局执行上下文
 *      - 对全局数据进行预处理
 *          - var 定义的全局变量 ==> undefined， 添加为 window 的属性
 *          - function 声明的全局函数 ==> 赋值(fun), 添加为 window 的方法
 *          - this ==> 赋值(window)
 *      - 开始执行全局代码
 * 3. 函数执行上下文
 *      - 在调用函数，准备执行函数体之前，创建对应的函数执行上下文(虚拟的，存在与栈中)
 *      - 对局部数据进行预处理
 *          - 形参变量 ==> 赋值(实参) ==> 添加为执行上下文的属性
 *          - arguments ==> 赋值(实参列表)，添加为执行上下文的属性
 *          - var 定义的局部变量 ==> undefined 添加为执行上下文的属性
 *          - function 声明的函数 ==> 赋值(fun) 添加为执行上下文的方法
 *          - this ==> 赋值(调用函数的对象)
 *      - 开始执行函数体代码
```

##### 执行上下文栈

```
 * 1. 在全局代码执行前 JS引擎就会创建一个栈来存储管理所有的执行上下文对象
 * 2. 在全局执行上下文(window)确定后，将其添加到栈中(压栈)
 * 3. 在函数执行上下文创建后，将其添加到栈中(压栈)
 * 4. 在当前函数执行完后 将栈顶的对象移除(出栈)
 * 5. 当所有的代码执行完后 栈中只剩下window
```

#### 作用域与作用域链

###### 作用域

###### 作用域与执行上下文

###### 作用域链

#### 闭包

###### 理解闭包



 