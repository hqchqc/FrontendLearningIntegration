#  JavaScript高级

### 一. 基础总结深入

##### 数据类型

###### 1. 分类

  - 基本(值)数据类型
      - String
      - Number
      - Boolean
      - Null
      - Undefined
      - Symbol
  - 对象(引用)数据类型
    	 - Object
        	 - Function：特殊的对象(可以执行)
          	 - Array：特殊的对象(数值下标，内部数据是有序的)

###### 2. 判断

 - typeof（返回的是对应类型的一个字符串形式）
   	- 可以判断 number boolean string undefined
      	- 不能判断 null 和 object , array 和 object

 - instanceof (返回的是一个布尔值 用来判断 a 是否是 b 的一个实例对象)
   	- 不能判断基本数据类型
      	- 用来判断对象的具体类型
 - ===
   	- 可以判断null undefined

###### 3. 补充

- undefined 与 null 的区别？
  - undefined代表定义了未赋值
  - null定义了 也赋值了 只是值为null
- 什么时候给变量赋值为 null？
  - 初始赋值 表明将要赋值为对象
  - 结束前 让对象成为垃圾对象(被垃圾回收机制回收)
- 严格区别变量类型与数据类型？
  - 数据的类型
    - 基本类型
    - 对象类型i
  - 变量的类型(变量内存值的类型)
    - 基本类型：保存的就是基本类型的数据
    - 引用类型：保存的是地址值

##### 数据 _ 变量 _ 内存

###### 1. 什么是数据？

	- 存储在内存中代表特定信息的 ’ 东东 ‘ ,本质上是 010101...
	- 数据的特点：可传递,可运算
	- 一切皆数据
 - 内存中所有操作的目标：数据
   	- 算术运算
      	- 逻辑运算
      	- 赋值
              	- 运行函数

###### 2. 什么是变量？

	- 可变化的量,由变量名和变量值组成
	- 每个变量都对应的一块小内存,变量名用来查找对应的内存，变量值就是内存中保存的数据

###### 3. 什么是内存？

	- 内存条通电以后产生的可存储数据的空间(临时的)
	- 内存产生和死亡： 内存条(电路板) ==> 通电 ==> 产生内存空间 ==> 存储数据 ==> 处理数据 ==> 断电 ==> 内存空间和数据都消失
 - 一块小内存的 2 个数据
   	- 基本数据
      	- 地址值数据
- 内存的分类
  - 栈：全局变量和局部变量
  - 堆：对象

###### 4. 内存 数据 变量三者之间的关系

	- 内存用来存储数据的空间
 - 变量是内存的标识

###### 5. var a = xxx, a内存中到底保存的是什么？

	- xxx是基本数据类型 ， 保存的就是这个数据
	- xxx是对象 ， 保存的是对象的地址值
	- xxx是一个变量， 保存的xxx的内存内容(可能是基本数据，也可能是地址值)

###### 6. 关于变量赋值问题？

	-  n 个引用变量指向同一个对象，通过一个变量修改对象内部数据，另一个变量看到的是修改之后的数据
	-  2 个引用变量指向同一个对象, 让其中一个引用变量指向另一个对象，另一引用变量依然指向前一个对象

###### 7. 在js调用函数时传递变量参数时，是值传递还是引用传递？

	- 理解一：都是值(基本/地址值)传递
	- 理解二：可能是值传递，也可能是引用传递(地址值)

###### 8. Js引擎如何管理内存？

```
1. 内存的生命周期
    - 分配小内存空间，得到他的使用权
    - 存储数据，可以反复进行操作
    - 释放小内存空间
2. 释放内存
    - 局部变量： 函数执行完自动释放
    - 对象： 成为垃圾对象 ==> 垃圾回收器回收
    - 全局变量： 窗口关闭
```

##### 对象

###### 1. 什么是对象？

```
- 多个数据的封装体
- 用来保存多个数据的容器
- 一个对象代表现实中的一个事务
```

###### 2. 为什么要用对象？

```
- 统一管理多个数据
```

###### 3. 对象的组成？

```
- 属性： 属性名(字符串)和属性值(任意)组成
- 方法： 一种特别的属性(属性值是函数)
```

###### 4. 如何访问对象内部数据？

```
- .属性名: 编码简单，有时不能用
- ['属性名']： 编码麻烦，能通用
```

###### 5.  什么时候必须使用['属性名']的方式？

```
- 属性名包含特殊字符 - 空格
- 属性名不确定
```

##### 函数

###### 1. 什么是函数？

```
- 实现特定功能的 n 条语句的封装体
- 只有函数是可以执行的，其它类型的数据不执行
```

###### 2. 为什么要用函数？

```
- 提高代码复用性
- 便于阅读交流
```

###### 3. 如何定义函数？

```
- 函数声明
- 表达式
```

###### 4. 如何调用(执行)函数？

```
- test()：直接调用
- obj.test(): 通过对象调用
- new test(): new调用
- test.call/apply(obj): 临时让test成为obj的方法进行调用
```

##### 回调函数

###### 1. 什么函数才是回调函数？

```
- 你定义的
- 你没有调用
- 但最终它执行的(在某个时刻或某个条件)
```

###### 2. 常见的回调函数？

```
- dom事件的回调函数
- 定时器回调函数
- Ajax请求回调函数
- 生命周期回调函数
```

##### IIFE

###### 1. 理解

```
全称： Immediately-Invoked Function Expression
```

###### 2. 作用

```
- 隐藏实现
- 不会污染外部(全局)命名空间
- 用它来编码js模块
```

##### 函数中的this

###### 1. this是什么？

```
- 任何函数本质上都是通过某个对象来调用的，如果没有直接指定就是window
- 所有函数内部都有一个变量 this
- 它的值是调用函数的当前对象
```

###### 2. 如何确定this的值

```
- test(): window
- p.test(): p
- new test(): 新创建的对象
- p.call(obj): obj
```

##### 分号问题

###### 1. 以下两种情况不加分号有问题？

```
- 小括号开头的前一条语句
- 中方括号开头的前一条语句
```



### 二. 函数高级

#### 原型与原型链

##### 原型

###### 1. 函数的 prototype 属性

```
- 每个函数都有一个 prototype 属性，它默认指向一个 Object 空对象(即称为原型对象)
- 原型对象中有一个属性 constructor 它指向函数对象
```

###### 2. 给原型对象添加属性(一般都是方法)

```
作用：函数的所有实例对象自动拥有原型中的属性(方法)
```

##### 显示原型与隐式原型

```
1. 每个函数 function 都有一个 prototype , 即显示原型(属性)
2. 每个实例对象都有一个 __proto__, 可称为隐式原型(属性)
3. 对象的隐式原型的值为其对应构造函数的显示原型的值
4. 内存结构
5. 总结：
    - 函数的 prototype 属性： 在定义函数时自动添加，默认值是一个空Object对象
    - 对象的 __proto__属性： 在创建对象时自动添加，默认值为构造函数的 prototype 属性值
    - 程序员能直接操作显示原型，但不能直接操作隐式原型(ES6之前)
```

##### 原型链

```
* 1. 原型链(图解)
*      访问一个对象的属性时：
*          先在自身属性中查找，找到返回
*          如果没有，再沿着__proto__这条链向上查找，找到返回
*          如果最终没找到，返回 undefined
*    别名： 隐式原型链
*    作用：查找对象的属性(方法)
* 2. 构造函数 / 原型 / 实体对象的关系(图解)
* 3. 构造函数 / 原型 / 实体对象的关系2(图解)

* 1. 函数的显示原型指向的对象：默认是空的Object对象(但Object不满足)
* 2. 所有的函数都是 Function 的实例(包括 Function 本身)
* 3. Object 的原型对象是原型链的尽头
```

![](https://cdn.jsdelivr.net/gh/hqchqc/CDN@5.0/constructor.png)

![](https://cdn.jsdelivr.net/gh/hqchqc/CDN@5.0/原型链一.png)

![](https://cdn.jsdelivr.net/gh/hqchqc/CDN@5.0/原型链二.png)

##### 原型链_属性问题

```
 * 1. 读取对象的属性值时： 会自动到原型链中查找
 * 2. 设置对象的属性值时： 不会查找原型链，如果当前对象中没有此属性，直接添加次属性并设置其值
 * 3. 方法一般定义在原型中，属性一般通过构造函数定义在对象本身
```

##### 探索instanceof

```
 * 1. instanceof是如何判断的？
 *      表达式： A instanceof B
 *      如果B函数的显示原型对象在A对象的原型链上，返回true，否则返回false
 * 2. Function是通过new自己产生的实例
```

#### 执行上下文与执行上下文栈

##### 变量提升与函数提升

```
* 1. 变量声明提升
 *      - 通过var定义(声明)的变量，在定义语句之前就可以访问到
 *      - 值 undefined
 * 2. 函数声明提升
 *      - 通过function声明的函数，在之前就可以直接调用
 *      - 值 函数定义(对象)
 * 3. 问题：变量提升和函数提升是如何产生的？
```

##### 执行上下文

```
 * 1. 代码分类(位置)
 *      - 全局代码
 *      - 函数(局部)代码
 * 2. 全局执行上下文
 *      - 在执行全局代码前将 window 确定为全局执行上下文
 *      - 对全局数据进行预处理
 *          - var 定义的全局变量 ==> undefined， 添加为 window 的属性
 *          - function 声明的全局函数 ==> 赋值(fun), 添加为 window 的方法
 *          - this ==> 赋值(window)
 *      - 开始执行全局代码
 * 3. 函数执行上下文
 *      - 在调用函数，准备执行函数体之前，创建对应的函数执行上下文(虚拟的，存在与栈中)
 *      - 对局部数据进行预处理
 *          - 形参变量 ==> 赋值(实参) ==> 添加为执行上下文的属性
 *          - arguments ==> 赋值(实参列表)，添加为执行上下文的属性
 *          - var 定义的局部变量 ==> undefined 添加为执行上下文的属性
 *          - function 声明的函数 ==> 赋值(fun) 添加为执行上下文的方法
 *          - this ==> 赋值(调用函数的对象)
 *      - 开始执行函数体代码
```

##### 执行上下文栈

```
 * 1. 在全局代码执行前 JS引擎就会创建一个栈来存储管理所有的执行上下文对象
 * 2. 在全局执行上下文(window)确定后，将其添加到栈中(压栈)
 * 3. 在函数执行上下文创建后，将其添加到栈中(压栈)
 * 4. 在当前函数执行完后 将栈顶的对象移除(出栈)
 * 5. 当所有的代码执行完后 栈中只剩下window
```

#### 作用域与作用域链

###### 作用域

```
 * 1. 理解
 *      - 就是一块"地盘" 一个代码段所在的区域
 *      - 他是静态的(相对于上下文对象) 在编写代码时就确定了
 * 2. 分类
 *      - 全局作用域
 *      - 局部作用域
 *      - 没有块作用域(ES6有了)
 * 3. 作用
 *      - 隔离变量 不同作用于下同名变量不会有冲突
```

###### 作用域与执行上下文

```
 * 1. 区别一
 *      - 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了，而不是在函数调用时
 *      - 全局执行上下文环境是在全局作用域确定之后 js 代码妈上执行之前创建
 *      - 函数执行上下文环境是在调用函数时 函数体代码执行之前创建
 * 2. 区别二
 *      - 作用域是静态的 只要函数定义好了就一直存在 且不会在变化
 *      - 执行上下文环境是动态的 调用函数时创建 函数调用结束时上下文环境就会自动释放
 * 3. 联系
 *      - 执行上下文环境(对象)是从属于所在的作用域
 *      - 全局上下文环境 ==> 全局作用域
 *      - 函数上下文环境 ==> 对应的函数使用域
```

###### 作用域链

```
 * 1. 理解
 *      - 多个上下级关系的作用域形成的链 它的方向是从下向上的(从内到外)
 *      - 查找变量时就是沿着作用域链来查找的
 * 2. 查找一个变量的查找规则
 *      - 在当前作用域下的执行上下文中查找对应的属性 如果有直接返回 否则进入2
 *      - 在上一级作用域的执行上下文中查找对应的属性 如果有直接返回 否则进入3
 *      - 再次执行2的相同操作 知道全局作用域 如果还找不到就抛出找不到的异常
```

#### 闭包

###### 理解闭包

```
 * 1. 如何产生闭包？
 *      - 当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时，就产生了闭包
 * 2. 闭包到底是什么？
 *      - 使用 chrome 调试查看
 *      - 理解一 闭包是嵌套的内部函数(绝大部分人)
 *      - 理解二 包含被引用变量(函数)的对象(极少数人)
 *      - 注意 闭包存在于嵌套的内部函数
 * 3. 产生闭包的条件？
 *      - 函数嵌套
 *      - 内部函数引用了外部函数的数据(变量 / 函数)
 *      - 函数被调用
```

###### 常见的闭包

```
 * 1. 将函数作为另一个函数的返回值
 * 2. 将函数作为实参传递给另一个函数调用
```

###### 闭包的作用

```
 * 1. 使用函数内部的变量在函数执行完后，仍然存活在内存中(延长了局部变量的生命周期)
 * 2. 让函数外部可以操作(独写)到函数内部的数据(变量/函数)
 * 
 * 问题：
 *      1. 函数执行完后 函数内部声明的局部变量是否还存在？  一般是不存在 存在与闭包中的变量才可能存在
 *      2. 在函数外部能直接访问函数内部的局部变量吗？   不能 但我们可以通过闭包让外部操作他
```

###### 闭包的生命周期

```
 * 1. 产生：在嵌套内部函数定义执行完时就产生了(不是在调用)
 * 2. 死亡：在嵌套的内部函数称为垃圾对象时 
```

###### 闭包的应用

```
 * 闭包的应用2：定义JS模块
 *      - 具有特定功能的JS文件
 *      - 将所有的数据和功能都封装在一个函数对象内部(私有的)
 *      - 只向外暴露一个包含n个方法的对象或函数
 *      - 模块的使用者 只需要通过模块暴露的对象调用方法来实现对应的功能
```

###### 闭包的缺点及解决

```
 * 1. 缺点：
 *      - 函数执行完后 函数内的局部变量没有释放 占用内存时间会变长
 *      - 容易造成内存泄漏
 * 2. 解决
 *      - 能不用闭包就不用
 *      - 及时释放
```

###### 内存溢出与内存泄漏

```
 * 1. 内存溢出
 *      - 一种程序运行时出现的错误
 *      - 当程序运行需要的内存超过了剩余内存时 就会抛出内存溢出的错误
 * 2. 内存泄漏
 *      - 占用的内存没有及时释放
 *      - 内存泄漏积累多了就容易导致内存溢出
 *      - 常见的内存泄漏
 *          - 意外的全局变量
 *          - 没有及时清理的计时器或回调函数
 *          - 闭包
```



### 三. 对象高级

##### 对象创建模式

###### object构造函数模式

```
 * 方式一 Object构造函数模式
 *      套路：先创建空Object对象 再动态添加属性/方法
 *      使用场景：起始时不确定对象内部数据
 *      问题： 语句太多
```

###### 对象字面量模式

```
 * 方法二：对象字面量模式
 *      - 套路： 使用 {} 创建对象 同时指定属性 / 方法
 *      - 适用场景： 起始时对象内部数据是确定的
 *      - 问题： 如果创建多个对象 有重复代码
```

###### 工厂模式

```
 * 方式三： 工厂模式
 *      - 套路： 通过工厂函数动态创建对象并返回
 *      - 使用场景： 需要创建多个对象
 *      - 问题: 对象没有一个具体的类型 都是Object类型
```

###### 自定义构造函数模式

```
 * 方式四： 自定义构造函数模式
 *      - 套路： 自定义构造函数 通过 new 创建对象
 *      - 使用场景： 需要创建多个类型确定的对象
 *      - 问题： 每个对象都有相同的数据 浪费内存    
```

###### 构造函数 + 原型的组合模式

```
 * 方法五： 构造函数+原型的组合模式
 *      - 套路： 自定义构造函数，属性再函数中初始化 方法添加到原型上
 *      - 使用场景： 需要创建多个类型确定的对象
```

##### 继承模式

###### 原型链继承

```
 * 方式一： 原型链继承
 *    1. 套路
 *       1. 定义父类型构造函数
 *       2. 给父类型的原型添加方法
 *       3. 定义子类型的构造函数
 *       4. 创建父类型的对象赋值给子类型的原型
 *       5. 将子类型原型的构造属性设置为子类型
 *       6. 给子类型原型添加方法
 *       7. 创建子类型的对象：可以调用父类型的方法
 *    2. 关键
 *       1. 子类型的原型为父类型的一个实例对象
 *    3. 缺点
 *      当我们在子类中修改父类的属性值的时候 如果属性值为基本数据类型 那么其它子类不会发生变化
 *      但是如果是引用数据类型 其它子类就会跟着发生变化
```

![](https://cdn.jsdelivr.net/gh/hqchqc/CDN@5.0/原型链继承.png)

###### 借用构造函数继承

```
 * 方式二： 借用构造函数继承(假的)
 *  1. 套路
 *      1. 定义父类型构造函数
 *      2. 定义子类型构造函数
 *      3. 在子类型构造函数中调用父类型构造
 * 2. 关键
 *      1. 在子类型构造函数中通过call()调用父类型构造函数
 * 3. 缺点
 *      所有的子类都会对父类中所有的属性和方法拷贝一份 占用内存大
```

###### 组合继承

```
 * 方式三 原型链 + 借用构造函数的组合继承
 *  1. 利用原型链实现对父类型对象的方法继承
 *  2. 利用 call 借用父类型构建函数初始化相同属性
```

### 四. 线程机制与事件机制

 ###### 线程与进程

```
 * 1. 进程：程序的一次执行, 它占有一片独有的内存空间
2. 线程： CPU的基本调度单位, 是程序执行的一个完整流程
3. 进程与线程
  * 一个进程中一般至少有一个运行的线程: 主线程
  * 一个进程中也可以同时运行多个线程, 我们会说程序是多线程运行的
  * 一个进程内的数据可以供其中的多个线程直接共享
  * 多个进程之间的数据是不能直接共享的
4. 浏览器运行是单进程还是多进程?
  * 有的是单进程
    * firefox
    * 老版IE
  * 有的是多进程
    * chrome
    * 新版IE
5. 如何查看浏览器是否是多进程运行的呢?
  * 任务管理器==>进程
6. 浏览器运行是单线程还是多线程?
  * 都是多线程运行的
```

###### 浏览器内核

```
 * 1. 什么是浏览器内核?
  * 支持浏览器运行的最核心的程序
2. 不同的浏览器可能不太一样
  * Chrome, Safari: webkit
  * firefox: Gecko
  * IE: Trident
  * 360,搜狗等国内浏览器: Trident + webkit
3. 内核由很多模块组成
  * html,css文档解析模块 : 负责页面文本的解析
  * dom/css模块 : 负责dom/css在内存中的相关处理
  * 布局和渲染模块 : 负责页面的布局和效果的绘制
  * 布局和渲染模块 : 负责页面的布局和效果的绘制

  * 定时器模块 : 负责定时器的管理
  * 网络请求模块 : 负责服务器请求(常规/Ajax)
  * 事件响应模块 : 负责事件的管理
```

###### 定时器引发的思考

```
 * 1. 定时器是真的定时执行的吗？
 *      定时器并不能保证真正定时执行
 *      一般会延迟一丁点(可以接受) 也有可能延迟很长时间(不能接受)
 * 2. 定时器回调函数是在分线程执行的吗？
 *      在主线程执行的 js是单线程的
 * 3. 定时器是如何实现的？
 *      事件循环模型
```

###### js是单线程的

```
 * 1. 如何证明JS执行是单线程的？
 *      setTimeout()的回调函数是在主线程执行的
 *      定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行
 * 2. 为什么js要用单线程模式 而不用多线程模式？
 *      JavaScript的单线程(只能有一个线程更新界面) 与它的用途有关
 *      作为浏览器脚本语言 JavaScript的主要用途是与用户互动 以及操作DOM
 *      这据欸的那个了它只能是单线程 否则会带来很复杂的同步问题
 * 
 * 3. 代码的分类
 *      初始化代码
 *      回调代码
 * 4. js引擎执行代码的基本流程
 *      先执行初始化代码： 包含一些特别的代码
 *          设置定时器
 *          绑定监听
 *          发送Ajax请求
 *      后面再某个时刻才会执行回调代码
```

###### 事件循环模型

```
 * 1. 所有代码分类
 *      初始化执行代码(同步代码)： 包含绑定dom事件监听 设置定时器 发送Ajax请求的代码
 *      回调执行代码(异步代码)： 处理回调逻辑
 * 2. js引擎执行代码的基本流程
 *      初始化代码 ==> 回调代码
 * 3. 模型的2个重要组成部分
 *      事件(定时器 / DOM管理 / Ajax)管理模块
 *      回调的队列
 * 4. 模型的运转流程
 *      执行初始化代码 将事件回调函数交给对应模块管理
 *      当事件发生时 管理模块会将回调函数及其数据添加到回调队列中
 *      只有当初始化代码执行完后(可能要一定时间) 才会遍历读取回调队列中的回调函数执行
```

###### Web worker

```
        1. H5规范中提供了js分线程的实现 取名为 Web Works
        2. 相关API
            Worker: 构造函数，加载分线程执行的js文件
            Worker.prototype.onmessage: 用于接收另一个线程的回调函数
            Worker.prototype.postMessage: 向另一个线程发送消息
        3. 不足(只是为了能够不阻塞主线程 优化用户体验)
            worker内代码不能操作DOM(更新 UI)
            不能跨域加载JS
            不是每个浏览器都支持这个新特性
```



第四部分的线程机制与事件机制我感觉老师讲的优点绕了 这里我总结一下 看下面这句话即可

```
因为 js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。

微任务包括了 promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。

宏任务包括了 script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲
染等。
```

